Давайте рассмотрим каждый вопрос по порядку.

### 1. Что такое наследование?

**Наследование** — это один из ключевых принципов объектно-ориентированного программирования (ООП), позволяющий одному классу (наследнику) унаследовать свойства и методы другого класса (родителя). В Swift наследование используется для создания иерархии классов, где базовый класс предоставляет общий функционал, а дочерние классы могут его расширять или изменять.

Пример:

```swift
class Animal {
    var name: String

    init(name: String) {
        self.name = name
    }

    func makeSound() {
        print("Some generic sound")
    }
}

class Dog: Animal {
    func bark() {
        print("Woof!")
    }
}

let dog = Dog(name: "Buddy")
dog.makeSound() // Наследуется от Animal
dog.bark()      // Собственный метод Dog
```

### 2. Что такое переопределение? Что можно переопределять?

**Переопределение** (overriding) — это механизм, позволяющий дочернему классу предоставить свою реализацию метода, свойства или сабскрипта, который уже определен в его родительском классе. Переопределение используется для изменения или расширения поведения, унаследованного от родительского класса.

Переопределять можно:

- Методы (включая методы класса)
- Свойства (включая вычисляемые свойства)
- Сабскрипты (subscripts)

Пример:

```swift
class Animal {
    func makeSound() {
        print("Some generic sound")
    }
}

class Dog: Animal {
    override func makeSound() { // Переопределение метода makeSound
        print("Woof!")
    }
}

let dog = Dog()
dog.makeSound() // Выведет "Woof!"
```

### 3. Что такое протоколы?

**Протоколы** в Swift — это контракты или соглашения, которые определяют список методов, свойств или требований, которым должны соответствовать классы, структуры или перечисления, реализующие этот протокол. Протоколы не содержат реализации, только сигнатуры методов и свойств.

Пример:

```swift
protocol Vehicle {
    var speed: Int { get set }
    func drive()
}
```

### 4. Для чего служат протоколы?

Протоколы используются для определения интерфейсов, которые могут быть реализованы различными классами или структурами. Это позволяет создать общие методы и свойства для объектов разных типов, обеспечивая гибкость и полиморфизм в коде.

Пример использования протоколов:

```swift
protocol Vehicle {
    var speed: Int { get set }
    func drive()
}

class Car: Vehicle {
    var speed: Int = 0

    func drive() {
        print("Driving at \(speed) km/h")
    }
}

class Bike: Vehicle {
    var speed: Int = 0

    func drive() {
        print("Cycling at \(speed) km/h")
    }
}
```

### 5. Что такое расширение протоколов?

**Расширение протоколов** (protocol extensions) позволяет добавлять реализацию методов и свойств к протоколам. Это дает возможность предоставлять базовую реализацию по умолчанию, которую могут использовать все типы, соответствующие этому протоколу.

Пример:

```swift
protocol Vehicle {
    var speed: Int { get set }
    func drive()
}

extension Vehicle {
    func stop() {
        speed = 0
        print("Vehicle stopped")
    }
}

class Car: Vehicle {
    var speed: Int = 0

    func drive() {
        print("Driving at \(speed) km/h")
    }
}

let car = Car()
car.drive()
car.stop() // Использует метод из расширения протокола
```

### 6. Какой синтаксис у протоколов?

Синтаксис определения протокола в Swift следующий:

```swift
protocol ProtocolName {
    // Определение методов и свойств
    var someProperty: Int { get set }
    func someMethod()
}
```

Пример:

```swift
protocol Drivable {
    var speed: Int { get set }
    func drive()
}
```

### 7. Что из себя представляет делегирование?

**Делегирование** — это паттерн проектирования, который позволяет одному объекту передавать ответственность за выполнение определенной задачи другому объекту. В Swift делегирование часто реализуется с помощью протоколов, где один объект (делегат) реализует протокол, а другой объект вызывает методы этого протокола.

Пример использования делегирования:

```swift
protocol DrivableDelegate {
    func didStartDriving()
}

class Car {
    var delegate: DrivableDelegate?

    func startDriving() {
        // Некоторая логика
        delegate?.didStartDriving()
    }
}

class Driver: DrivableDelegate {
    func didStartDriving() {
        print("Driver started driving")
    }
}

let car = Car()
let driver = Driver()
car.delegate = driver
car.startDriving() // Выведет "Driver started driving"
```

Таким образом, делегирование позволяет объектам взаимодействовать и обмениваться информацией, сохраняя при этом четкое разграничение обязанностей.